#!/usr/bin/env bash
set -euo pipefail

_select_zoxide_dir() {
	if ! command -v zoxide >/dev/null 2>&1; then
		echo "Error: Required command 'zoxide' not found. Please install it." >&2
		exit 1
	fi

	local zoxide_preview_cmd='ls -ap --color=always {}'
	if command -v tree >/dev/null 2>&1; then
		# Use tree for a richer preview if available
		zoxide_preview_cmd='tree -C {} | head -n 30'
	fi

	# Use fzf to select a directory from zoxide's list.
	# The '|| true' prevents the script from exiting if the user cancels fzf.
	local dir
	dir=$(zoxide query -l | fzf --reverse --preview "$zoxide_preview_cmd" || true)
	echo "$dir"
}

main() {
	if [[ -z "${TMUX-}" ]]; then
		echo "Error: This script must be run inside a tmux session." >&2
		exit 1
	fi

	local pane_id
	local pane_dir
	local pane_pid
	pane_id=$(tmux display-message -p '#{pane_id}')
	pane_dir=$(tmux display-message -p '#{pane_current_path}')
	pane_pid=$(tmux display-message -p '#{pane_pid}')

	# --- Argument Parsing ---
	local use_git_root=false
	local use_zoxide=false
	local dir_only=false
	local path_arg=""

	while [[ $# -gt 0 ]]; do
		case "$1" in
			--git-root|-g)
				use_git_root=true
				shift
				;;
			--zoxide)
				use_zoxide=true
				shift
				;;
			--dir-only)
				dir_only=true
				shift
				;;
			-*)
				echo "Error: Unknown option '$1'" >&2
				exit 1
				;;
			*)
				if [[ -n "$path_arg" ]]; then
					echo "Error: Only one path argument is allowed." >&2
					exit 1
				fi
				path_arg="$1"
				shift
				;;
		esac
	done

	# Check for conflicting arguments
	if $use_zoxide && [[ -n "$path_arg" ]]; then
		echo "Error: The --zoxide flag cannot be used with a path argument." >&2
		exit 1
	fi

	if $dir_only && ! $use_zoxide; then
		echo "Error: The --dir-only flag can only be used with --zoxide." >&2
		exit 1
	fi

	local search_dir

	if $use_zoxide; then
		search_dir=$(_select_zoxide_dir)
		# Exit gracefully if no directory was selected from fzf
		if [[ -z "$search_dir" ]]; then
			exit 0
		fi
	else
		search_dir="${path_arg:-$pane_dir}"

		# Convert to absolute path if relative
		if [[ ! "$search_dir" = /* ]]; then
			search_dir="$pane_dir/$search_dir"
		fi

		# Use realpath to resolve ".." and "." components and get a canonical path
		local realpath_cmd="realpath"
		[[ "$OSTYPE" == "darwin"* ]] && realpath_cmd="grealpath"

		if command -v "$realpath_cmd" >/dev/null 2>&1; then
			search_dir=$("$realpath_cmd" -m "$search_dir")
		fi
	fi

	# Verify the directory exists (this check is now common to both paths)
	if [[ ! -d "$search_dir" ]]; then
		echo "Error: Directory '$search_dir' does not exist." >&2
		exit 1
	fi

	# --- Mode Detection ---
	local at_prefix_mode=false
	if pgrep -P "$pane_pid" -f ".*claude.*|node.*gemini" >/dev/null; then
		at_prefix_mode=true
	fi

	local git_root
	git_root=$(git rev-parse --show-toplevel 2>/dev/null || true)
	if $use_git_root && [[ -z "$git_root" ]]; then
		echo "Error: --git-root flag used, but not inside a git repository." >&2
		exit 1
	fi

	# If --dir-only is set, just output the directory path and exit
	if $dir_only; then
		# When using zoxide, output absolute path
		local output_path="$search_dir"

		# Format output for at_prefix_mode if needed
		if $at_prefix_mode; then
			tmux send-keys -t "$pane_id" "@$output_path "
		else
			printf -v escaped_path "%q" "$output_path"
			tmux send-keys -t "$pane_id" "$escaped_path "
		fi
		exit 0
	fi

	# --- Command Detection ---
	local fd_cmd
	if command -v fd >/dev/null 2>&1; then
		fd_cmd="fd"
	elif command -v fdfind >/dev/null 2>&1; then
		fd_cmd="fdfind"
	else
		echo "Error: Required command 'fd' or 'fdfind' not found. Please install it." >&2
		exit 1
	fi

	# --- File Selection ---
	local preview_cmd="cat {}"
	if command -v bat >/dev/null 2>&1; then
		preview_cmd="bat --style=numbers --color=always {}"
	elif command -v batcat >/dev/null 2>&1; then
		preview_cmd="batcat --style=numbers --color=always {}"
	fi

	# Allow passing additional fd flags through environment variable
	local fd_flags="${TMUX_FILE_PICKER_FD_FLAGS:--H --type f --exclude .git}"

	local selected_files_str
	selected_files_str=$(cd "$search_dir" && $fd_cmd $fd_flags | fzf --multi --reverse --preview "$preview_cmd" || true)

	if [[ -z "$selected_files_str" ]]; then
		exit 0
	fi

	# --- Path Processing ---
	selected_files=()
	while IFS= read -r line; do
		if [[ -n "$line" ]]; then
			selected_files+=("$line")
		fi
	done <<<"$selected_files_str"

	# --- Path Relativization ---
	local relative_paths=()

	# When using zoxide, return absolute paths
	if $use_zoxide; then
		# Prepend search directory to each filename to create full paths
		relative_paths=("${selected_files[@]/#/$search_dir\/}")
	else
		# Standard path relativization logic
		local base_dir_for_relativization=""

		if $use_git_root; then
			base_dir_for_relativization="$git_root"
		elif [[ "$search_dir" != "$pane_dir" ]]; then
			base_dir_for_relativization="$pane_dir"
		fi

		if [[ -n "$base_dir_for_relativization" ]]; then
			# We need to calculate relative paths against a specific base directory
			local realpath_cmd="realpath"
			[[ "$OSTYPE" == "darwin"* ]] && realpath_cmd="grealpath"

			# Prepend search directory to each filename to create full paths
			local full_paths=("${selected_files[@]/#/$search_dir\/}")

			while IFS= read -r line; do
				if [[ -n "$line" ]]; then
					relative_paths+=("$line")
				fi
			done < <("$realpath_cmd" --relative-to="$base_dir_for_relativization" "${full_paths[@]}")
		else
			# Paths are already relative to the correct directory (the pane_dir)
			relative_paths=("${selected_files[@]}")
		fi
	fi

	# --- Output Formatting ---
	local files_oneline
	if $at_prefix_mode; then
		# Prefix each file with '@' and join with spaces
		printf -v files_oneline "@%s " "${relative_paths[@]}"
	else
		# Shell-escape each file path and join with spaces
		local escaped_paths=()
		for path in "${relative_paths[@]}"; do
			printf -v escaped_path "%q" "$path"
			escaped_paths+=("$escaped_path")
		done
		files_oneline=$(printf "%s " "${escaped_paths[@]}")
	fi

	# --- Send to Tmux ---
	tmux send-keys -t "$pane_id" "$files_oneline"
}

main "$@"

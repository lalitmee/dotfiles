#!/bin/bash
# Brain repo paths
PERSONAL_BRAIN_DIR="$HOME/Projects/Personal/Github/second-brain"
WORK_BRAIN_DIR="$HOME/Projects/Work/Github/second-brain"
BRAIN="$1" # expects 'personal' or 'work'

if [[ "$BRAIN" != "personal" && "$BRAIN" != "work" ]]; then
    echo "‚ùå ERROR: Please specify 'personal' or 'work' as the first argument"
    exit 1
fi

# Select the correct directory
if [[ "$BRAIN" == "personal" ]]; then
    TARGET_DIR="$PERSONAL_BRAIN_DIR"
else
    TARGET_DIR="$WORK_BRAIN_DIR"
fi

# Log configuration
LOG_DIR="$HOME/.local/share/second-brain/logs"
SUCCESS_LOG="$LOG_DIR/backup-$BRAIN-success.log"
ERROR_LOG="$LOG_DIR/backup-$BRAIN-error.log"
MAX_LOG_SIZE=$((5 * 1024 * 1024)) # 5 MB in bytes
SUCCESS_RETENTION_DAYS=7
ERROR_RETENTION_DAYS=30

# Icon path for notifications
ICON_PATH="$HOME/.config/icons/brain.png"

# Create log directory if it doesn't exist
mkdir -p "$LOG_DIR"

# Function to rotate log if it exceeds size limit
rotate_log_if_needed() {
    local log_file="$1"
    if [[ -f "$log_file" ]]; then
        local log_size=$(stat -f%z "$log_file" 2> /dev/null || stat -c%s "$log_file" 2> /dev/null)
        if [[ $log_size -gt $MAX_LOG_SIZE ]]; then
            mv "$log_file" "${log_file}.old"
            echo "üîÑ Rotated log file (exceeded 5 MB)" > "$log_file"
        fi
    fi
}

# Function to cleanup old logs
cleanup_old_logs() {
    # Clean success logs older than 7 days
    find "$LOG_DIR" -name "backup-*-success.log*" -type f -mtime +$SUCCESS_RETENTION_DAYS -delete 2> /dev/null

    # Clean error logs older than 30 days
    find "$LOG_DIR" -name "backup-*-error.log*" -type f -mtime +$ERROR_RETENTION_DAYS -delete 2> /dev/null
}

# Function to start a new log session
start_log_session() {
    local log_file="$1"

    rotate_log_if_needed "$log_file"

    {
        echo ""
        echo "============================================================"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Backup Run Started"
        echo "------------------------------------------------------------"
    } >> "$log_file"
}

# Function to end log session
end_log_session() {
    local log_file="$1"
    echo "============================================================" >> "$log_file"
}

# Function to log message (without separator)
log_message() {
    local log_file="$1"
    local message="$2"
    echo "$message" >> "$log_file"
}

# Function to send notifications
send_notification() {
    local title="$1"
    local message="$2"
    local urgency="${3:-normal}" # low, normal, critical
    local icon="${4:-$ICON_PATH}"

    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS notification
        osascript -e "display notification \"$message\" with title \"$title\" sound name \"default\""
    else
        # Linux notification (tries notify-send first, then dunstify)
        if command -v notify-send &> /dev/null; then
            notify-send -u "$urgency" -i "$icon" "$title" "$message"
        elif command -v dunstify &> /dev/null; then
            dunstify -u "$urgency" -i "$icon" "$title" "$message"
        fi
    fi
}

echo "------------------------------------------------------------"
echo "üß† $BRAIN backup started at: $(date '+%Y-%m-%d %H:%M:%S')"

# Start logging session
start_log_session "$SUCCESS_LOG"

# Run cleanup on each execution
cleanup_old_logs

# 1. Try to cd into the brain directory
if ! cd "$TARGET_DIR" 2> /dev/null; then
    ERROR_MSG="Failed to cd into $TARGET_DIR"
    echo "‚ùå ERROR: $ERROR_MSG"
    start_log_session "$ERROR_LOG"
    log_message "$ERROR_LOG" "CD Failed: $ERROR_MSG"
    end_log_session "$ERROR_LOG"
    end_log_session "$SUCCESS_LOG"
    send_notification "üß† Second Brain Backup Failed" "$ERROR_MSG" "critical"
    exit 1
fi

# 2. Abort any unfinished rebase (to prevent stuck state)
git rebase --abort 2> /dev/null

# 3. Pull latest changes with rebase to avoid merge commits
echo "üì• Pulling latest changes..."
log_message "$SUCCESS_LOG" "Pull started..."

PULL_OUTPUT=$(git pull --rebase --no-edit 2>&1)
PULL_STATUS=$?

if [[ $PULL_STATUS -ne 0 ]]; then
    ERROR_MSG="Git pull failed for $BRAIN brain"
    echo "‚ùå ERROR: $ERROR_MSG"
    start_log_session "$ERROR_LOG"
    log_message "$ERROR_LOG" "Pull Failed:"
    log_message "$ERROR_LOG" "$PULL_OUTPUT"
    end_log_session "$ERROR_LOG"
    end_log_session "$SUCCESS_LOG"
    send_notification "üß† Second Brain Backup Failed" "$ERROR_MSG\n\nCheck: $ERROR_LOG" "critical"
    exit 1
else
    log_message "$SUCCESS_LOG" "Pull completed successfully"
fi

# 4. Check for changes (modified, staged, OR untracked files)
HAS_CHANGES=false
if ! git diff --quiet || ! git diff --cached --quiet || [ -n "$(git ls-files --others --exclude-standard)" ]; then
    HAS_CHANGES=true
    echo "üìù Changes detected, committing..."
    log_message "$SUCCESS_LOG" "Commit started..."

    git add --all
    COMMIT_OUTPUT=$(git commit -m "auto: $BRAIN backup on $(date '+%Y-%m-%d %H:%M:%S')" 2>&1)
    COMMIT_STATUS=$?

    if [[ $COMMIT_STATUS -ne 0 ]]; then
        ERROR_MSG="Git commit failed for $BRAIN brain"
        echo "‚ùå ERROR: $ERROR_MSG"
        start_log_session "$ERROR_LOG"
        log_message "$ERROR_LOG" "Commit Failed:"
        log_message "$ERROR_LOG" "$COMMIT_OUTPUT"
        end_log_session "$ERROR_LOG"
        end_log_session "$SUCCESS_LOG"
        send_notification "üß† Second Brain Backup Failed" "$ERROR_MSG\n\nCheck: $ERROR_LOG" "critical"
        exit 1
    else
        echo "‚úÖ Changes committed"
        log_message "$SUCCESS_LOG" "Commit successful"
    fi
else
    echo "‚úÖ No local changes to commit"
    log_message "$SUCCESS_LOG" "No changes to commit"
fi

# 5. Check if we need to push (local is ahead of remote)
if git rev-parse @{u} > /dev/null 2>&1; then
    LOCAL=$(git rev-parse @)
    REMOTE=$(git rev-parse @{u})

    if [ "$LOCAL" != "$REMOTE" ]; then
        echo "üì§ Local is ahead of remote, pushing..."
        log_message "$SUCCESS_LOG" "Push started..."

        # Push with retry logic
        MAX_RETRIES=3
        RETRY_DELAY=5
        PUSH_SUCCESS=false

        for i in $(seq 1 $MAX_RETRIES); do
            PUSH_OUTPUT=$(git push 2>&1)
            PUSH_STATUS=$?

            if [[ $PUSH_STATUS -eq 0 ]]; then
                echo "‚úÖ $BRAIN backup pushed successfully"
                log_message "$SUCCESS_LOG" "Push successful"
                PUSH_SUCCESS=true
                send_notification "üß† Second Brain Backup Success" "$BRAIN brain backed up successfully" "normal"
                break
            else
                if [ $i -lt $MAX_RETRIES ]; then
                    echo "‚ö†Ô∏è  Push failed, retrying in ${RETRY_DELAY}s... (attempt $i/$MAX_RETRIES)"
                    sleep $RETRY_DELAY
                else
                    ERROR_MSG="Git push failed after $MAX_RETRIES attempts for $BRAIN brain"
                    echo "‚ùå ERROR: $ERROR_MSG"
                    start_log_session "$ERROR_LOG"
                    log_message "$ERROR_LOG" "Push Failed (after $MAX_RETRIES attempts):"
                    log_message "$ERROR_LOG" "$PUSH_OUTPUT"
                    end_log_session "$ERROR_LOG"
                    end_log_session "$SUCCESS_LOG"
                    send_notification "üß† Second Brain Backup Failed" "$ERROR_MSG\n\nCheck: $ERROR_LOG" "critical"
                    exit 1
                fi
            fi
        done
    else
        echo "‚úÖ Already up to date with remote"
        log_message "$SUCCESS_LOG" "Already up to date with remote"
        # No notification when already up to date (reduces noise)
    fi
else
    WARNING_MSG="No upstream branch configured for $BRAIN brain"
    echo "‚ö†Ô∏è  $WARNING_MSG, skipping push check"
    log_message "$SUCCESS_LOG" "$WARNING_MSG"
    send_notification "üß† Second Brain Warning" "$WARNING_MSG" "normal"
fi

echo "‚úÖ $BRAIN backup completed at: $(date '+%Y-%m-%d %H:%M:%S')"
log_message "$SUCCESS_LOG" "Backup completed successfully"
end_log_session "$SUCCESS_LOG"

return {
    { --[[ mini.nvim ]]
        "echasnovski/mini.nvim",
        version = "*",
        event = "VeryLazy",
        config = function()
            require("mini.pairs").setup()
        end,
        enabled = false,
    },

    { --[[ mini.pairs ]]
        "echasnovski/mini.pairs",
        event = "VeryLazy",
        opts = {},
        enabled = false,
    },

    { --[[ mini.animate ]]
        "echasnovski/mini.animate",
        event = "VeryLazy",
        opts = {
            cursor = {
                enable = false,
            },
        },
        enabled = false,
    },

    { --[[ mini.bufremove ]]
        "echasnovski/mini.bufremove",
        event = "VeryLazy",
        opts = {},
    },

    { --[[ mini.indentscope ]]
        "echasnovski/mini.indentscope",
        event = "VeryLazy",
        opts = {
            symbol = "â”‚",
            -- options = { try_as_border = true },
        },
    },

    { --[[ mini.ai ]]
        "echasnovski/mini.ai",
        keys = {
            { "[f", desc = "Prev function" },
            { "]f", desc = "Next function" },
        },
        opts = function()
            -- add treesitter jumping
            ---@param capture string
            ---@param start boolean
            ---@param down boolean
            local function jump(capture, start, down)
                local rhs = function()
                    local parser = vim.treesitter.get_parser()
                    if not parser then
                        return vim.notify("No treesitter parser for the current buffer", vim.log.levels.ERROR)
                    end

                    local query = vim.treesitter.query.get(vim.bo.filetype, "textobjects")
                    if not query then
                        return vim.notify("No textobjects query for the current buffer", vim.log.levels.ERROR)
                    end

                    local cursor = vim.api.nvim_win_get_cursor(0)

                    ---@type {[1]:number, [2]:number}[]
                    local locs = {}
                    for _, tree in ipairs(parser:trees()) do
                        for capture_id, node, _ in query:iter_captures(tree:root(), 0) do
                            if query.captures[capture_id] == capture then
                                local range = { node:range() } ---@type number[]
                                local row = (start and range[1] or range[3]) + 1
                                local col = (start and range[2] or range[4]) + 1
                                if down and row > cursor[1] or (not down) and row < cursor[1] then
                                    table.insert(locs, { row, col })
                                end
                            end
                        end
                    end
                    return pcall(vim.api.nvim_win_set_cursor, 0, down and locs[1] or locs[#locs])
                end

                local c = capture:sub(1, 1):lower()
                local lhs = (down and "]" or "[") .. (start and c or c:upper())
                local desc = (down and "Next " or "Prev ")
                    .. (start and "start" or "end")
                    .. " of "
                    .. capture:gsub("%..*", "")
                vim.keymap.set("n", lhs, rhs, { desc = desc })
            end

            for _, capture in ipairs({ "function.outer", "class.outer" }) do
                for _, start in ipairs({ true, false }) do
                    for _, down in ipairs({ true, false }) do
                        jump(capture, start, down)
                    end
                end
            end
        end,
        enabled = false,
    },
}
